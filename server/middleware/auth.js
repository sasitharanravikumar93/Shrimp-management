/**
 * Authentication and Authorization Middleware
 */

const jwt = require('jsonwebtoken'); \nconst User = require('../models/User'); \nconst { getConfig } = require('../config'); \nconst { \n  UnauthorizedError, \n  ForbiddenError, \n  asyncHandler\n } = require('../utils/errorHandler'); \n\nconst config = getConfig(); \n\n/**\n * Middleware to authenticate JWT tokens\n */\nconst authenticate = asyncHandler(async (req, res, next) => { \n  let token; \n  \n  // Get token from header\n  if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {\n    token = req.headers.authorization.split(' ')[1];\n  }\n  \n  // Get token from cookie if not in header\n  if (!token && req.cookies && req.cookies.token) {\n    token = req.cookies.token;\n  }\n  \n  if (!token) {\n    throw new UnauthorizedError('Access token is required');\n  }\n  \n  try {\n    // Verify token\n    const decoded = jwt.verify(token, config.security.jwtSecret, {\n      issuer: 'shrimpfarm-api',\n      audience: 'shrimpfarm-client'\n    });\n    \n    // Get user from database\n    const user = await User.findById(decoded.userId);\n    \n    if (!user) {\n      throw new UnauthorizedError('User no longer exists');\n    }\n    \n    if (!user.isActive) {\n      throw new UnauthorizedError('User account is deactivated');\n    }\n    \n    if (user.isLocked) {\n      throw new UnauthorizedError('User account is locked');\n    }\n    \n    // Add user to request object\n    req.user = user;\n    next();\n  } catch (error) {\n    if (error.name === 'JsonWebTokenError') {\n      throw new UnauthorizedError('Invalid token');\n    }\n    if (error.name === 'TokenExpiredError') {\n      throw new UnauthorizedError('Token has expired');\n    }\n    throw error;\n  }\n});\n\n/**\n * Middleware to check if user has required role\n */\nconst requireRole = (...roles) => {\n  return (req, res, next) => {\n    if (!req.user) {\n      throw new UnauthorizedError('Authentication required');\n    }\n    \n    if (!roles.includes(req.user.role)) {\n      throw new ForbiddenError(`Access denied. Required role: ${roles.join(' or ')}`);\n    }\n    \n    next();\n  };\n};\n\n/**\n * Middleware to check if user has required permission\n */\nconst requirePermission = (...permissions) => {\n  return (req, res, next) => {\n    if (!req.user) {\n      throw new UnauthorizedError('Authentication required');\n    }\n    \n    const hasPermission = permissions.some(permission => \n      req.user.permissions.includes(permission)\n    );\n    \n    if (!hasPermission) {\n      throw new ForbiddenError(`Access denied. Required permission: ${permissions.join(' or ')}`);\n    }\n    \n    next();\n  };\n};\n\n/**\n * Middleware to check if user owns the resource or has admin role\n */\nconst requireOwnership = (userIdField = 'userId') => {\n  return (req, res, next) => {\n    if (!req.user) {\n      throw new UnauthorizedError('Authentication required');\n    }\n    \n    // Admin can access any resource\n    if (req.user.role === 'admin') {\n      return next();\n    }\n    \n    // Check if user owns the resource\n    const resourceUserId = req.params[userIdField] || req.body[userIdField];\n    \n    if (!resourceUserId || resourceUserId !== req.user._id.toString()) {\n      throw new ForbiddenError('Access denied. You can only access your own resources');\n    }\n    \n    next();\n  };\n};\n\n/**\n * Optional authentication middleware - sets user if token is valid but doesn't require it\n */\nconst optionalAuthenticate = asyncHandler(async (req, res, next) => {\n  let token;\n  \n  // Get token from header\n  if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {\n    token = req.headers.authorization.split(' ')[1];\n  }\n  \n  // Get token from cookie if not in header\n  if (!token && req.cookies && req.cookies.token) {\n    token = req.cookies.token;\n  }\n  \n  if (token) {\n    try {\n      // Verify token\n      const decoded = jwt.verify(token, config.security.jwtSecret, {\n        issuer: 'shrimpfarm-api',\n        audience: 'shrimpfarm-client'\n      });\n      \n      // Get user from database\n      const user = await User.findById(decoded.userId);\n      \n      if (user && user.isActive && !user.isLocked) {\n        req.user = user;\n      }\n    } catch (error) {\n      // Silently fail - user remains unauthenticated\n    }\n  }\n  \n  next();\n});\n\n/**\n * Middleware for API key authentication (for system integrations)\n */\nconst authenticateApiKey = (req, res, next) => {\n  const apiKey = req.headers['x-api-key'];\n  \n  if (!apiKey) {\n    throw new UnauthorizedError('API key is required');\n  }\n  \n  // In a real implementation, you would validate the API key against a database\n  // For now, we'll use environment variable\n  if (apiKey !== process.env.API_KEY) {\n    throw new UnauthorizedError('Invalid API key');\n  }\n  \n  // Set a system user for API key requests\n  req.user = {\n    _id: 'system',\n    username: 'system',\n    role: 'system',\n    permissions: ['*'] // All permissions\n  };\n  \n  next();\n};\n\n/**\n * Helper function to generate permissions for a resource\n */\nconst generateResourcePermissions = (resource) => {\n  return {\n    read: `read:${resource}`,\n    write: `write:${resource}`,\n    delete: `delete:${resource}`\n  };\n};\n\n/**\n * Middleware factory for resource-based permissions\n */\nconst requireResourcePermission = (resource, action) => {\n  const permission = `${action}:${resource}`;\n  return requirePermission(permission);\n};\n\nmodule.exports = {\n  authenticate,\n  optionalAuthenticate,\n  authenticateApiKey,\n  requireRole,\n  requirePermission,\n  requireOwnership,\n  requireResourcePermission,\n  generateResourcePermissions\n};